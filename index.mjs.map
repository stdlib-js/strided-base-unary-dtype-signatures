{"version":3,"file":"index.mjs","sources":["../lib/main.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport safeCasts from '@stdlib/ndarray-safe-casts';\nimport resolveEnum from '@stdlib/strided-base-dtype-resolve-enum';\nimport resolveStr from '@stdlib/strided-base-dtype-resolve-str';\nimport format from '@stdlib/string-format';\n\n\n// FUNCTIONS //\n\n/**\n* Returns the intersection of two sorted lists.\n*\n* @private\n* @param {ArrayLikeObject} list1 - first sorted list\n* @param {ArrayLikeObject} list2 - second sorted list\n* @returns {ArrayLikeObject} result\n*\n* @example\n* var list1 = [ 'a', 'b', 'c', 'd' ];\n* var list2 = [ 'b', 'd', 'e' ];\n*\n* var out = intersection( list1, list2 );\n* // returns [ 'b', 'd' ]\n*/\nfunction intersection( list1, list2 ) {\n\tvar out;\n\tvar M;\n\tvar N;\n\tvar v;\n\tvar i;\n\tvar j;\n\tvar k;\n\n\tM = list1.length;\n\tN = list2.length;\n\n\tout = [];\n\tk = 0;\n\tfor ( i = 0; i < M; i++ ) {\n\t\tif ( k >= N ) {\n\t\t\tbreak;\n\t\t}\n\t\tv = list1[ i ];\n\t\tfor ( j = k; j < N; j++ ) {\n\t\t\tif ( v === list2[ j ] ) {\n\t\t\t\tk = j + 1;\n\t\t\t\tout.push( v );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn out;\n}\n\n/**\n* Resolves a list of data types to data type strings.\n*\n* @private\n* @param {ArrayLikeObject} dtypes - list of data types\n* @returns {(StringArray|Error)} data type strings (or an error)\n*\n* @example\n* var out = resolve( [ 1, 2, 3 ] );\n* // returns [...]\n*/\nfunction resolve( dtypes ) {\n\tvar out;\n\tvar dt;\n\tvar i;\n\n\tout = [];\n\tfor ( i = 0; i < dtypes.length; i++ ) {\n\t\tdt = resolveStr( dtypes[ i ] );\n\t\tif ( dt === null ) {\n\t\t\treturn new TypeError( format( 'invalid argument. Must provide recognized data types. Unable to resolve a data type string. Value: `%s`.', dtypes[ i ] ) );\n\t\t}\n\t\tout.push( dt );\n\t}\n\treturn out;\n}\n\n\n// MAIN //\n\n/**\n* Generates a list of unary interface signatures from strided array data types.\n*\n* ## Notes\n*\n* -   The function returns a strided array having a stride length of `2` (i.e., every `2` elements define a unary interface signature).\n* -   For each signature (i.e., set of two consecutive non-overlapping strided array elements), the first element is the input data type and the second element is the return data type.\n* -   All signatures follow type promotion rules.\n*\n* @param {Array} dtypes1 - list of supported data types for the first argument\n* @param {Array} dtypes2 - list of supported data types for the output argument\n* @param {Options} [options] - options\n* @param {boolean} [options.enums=false] - boolean flag indicating whether to return signatures as a list of enumeration constants\n* @throws {TypeError} must provide recognized data types\n* @returns {Array} strided array containing unary interface signatures\n*\n* @example\n* var dtypes = [\n*     'float64',\n*     'float32',\n*     'int32',\n*     'uint8'\n* ];\n*\n* var sigs = signatures( dtypes, dtypes );\n* // e.g., returns [ 'float32', 'float32', ... ]\n*/\nfunction signatures( dtypes1, dtypes2, options ) {\n\tvar casts;\n\tvar opts;\n\tvar tmp;\n\tvar out;\n\tvar dt1;\n\tvar dt2;\n\tvar t1;\n\tvar M;\n\tvar i;\n\tvar j;\n\n\tif ( arguments.length > 2 ) {\n\t\topts = options;\n\t} else {\n\t\topts = {};\n\t}\n\t// Resolve the list of provided data types to data type strings:\n\tdt1 = resolve( dtypes1 );\n\tif ( dt1 instanceof Error ) {\n\t\tthrow dt1;\n\t}\n\tif ( dtypes2 === dtypes1 ) { // don't do work if we don't need to\n\t\tdt2 = dt1;\n\t} else {\n\t\tdt2 = resolve( dtypes2 );\n\t\tif ( dt2 instanceof Error ) {\n\t\t\tthrow dt2;\n\t\t}\n\t}\n\t// Sort the list of return dtypes:\n\tdt2.sort();\n\n\t// Generate the list of signatures...\n\tM = dt1.length;\n\tout = [];\n\tfor ( i = 0; i < M; i++ ) {\n\t\tt1 = dt1[ i ];\n\n\t\t// Resolve the list of safe casts for the input dtype:\n\t\tcasts = safeCasts( t1 );\n\t\tif ( casts === null ) {\n\t\t\tcontinue;\n\t\t}\n\t\t// Remove safe casts which are not among the supported output dtypes:\n\t\tcasts = intersection( dt2, casts.sort() );\n\n\t\t// Generate signatures for allowed casts...\n\t\tfor ( j = 0; j < casts.length; j++ ) {\n\t\t\tout.push( t1, casts[ j ] );\n\t\t}\n\t}\n\tif ( opts.enums ) {\n\t\ttmp = [];\n\t\tfor ( i = 0; i < out.length; i++ ) {\n\t\t\ttmp.push( resolveEnum( out[ i ] ) );\n\t\t}\n\t\tout = tmp;\n\t}\n\treturn out;\n}\n\n\n// EXPORTS //\n\nexport default signatures;\n"],"names":["intersection","list1","list2","out","M","N","v","i","j","k","length","push","resolve","dtypes","dt","resolveStr","TypeError","format","signatures","dtypes1","dtypes2","options","casts","opts","tmp","dt1","dt2","t1","arguments","Error","sort","safeCasts","enums","resolveEnum"],"mappings":";;wYA6CA,SAASA,EAAcC,EAAOC,GAC7B,IAAIC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EAOJ,IALAL,EAAIH,EAAMS,OACVL,EAAIH,EAAMQ,OAEVP,EAAM,GACNM,EAAI,EACEF,EAAI,EAAGA,EAAIH,KACXK,GAAKJ,GADSE,IAKnB,IADAD,EAAIL,EAAOM,GACLC,EAAIC,EAAGD,EAAIH,EAAGG,IACnB,GAAKF,IAAMJ,EAAOM,GAAM,CACvBC,EAAID,EAAI,EACRL,EAAIQ,KAAML,GACV,KACA,CAGH,OAAOH,CACR,CAaA,SAASS,EAASC,GACjB,IAAIV,EACAW,EACAP,EAGJ,IADAJ,EAAM,GACAI,EAAI,EAAGA,EAAIM,EAAOH,OAAQH,IAAM,CAErC,GAAY,QADZO,EAAKC,EAAYF,EAAQN,KAExB,OAAO,IAAIS,UAAWC,EAAQ,2GAA4GJ,EAAQN,KAEnJJ,EAAIQ,KAAMG,EACV,CACD,OAAOX,CACR,CAgCA,SAASe,EAAYC,EAASC,EAASC,GACtC,IAAIC,EACAC,EACAC,EACArB,EACAsB,EACAC,EACAC,EACAvB,EACAG,EACAC,EASJ,GANCe,EADIK,UAAUlB,OAAS,EAChBW,EAEA,CAAA,GAGRI,EAAMb,EAASO,cACKU,MACnB,MAAMJ,EAEP,GAAKL,IAAYD,EAChBO,EAAMD,OAGN,IADAC,EAAMd,EAASQ,cACKS,MACnB,MAAMH,EASR,IALAA,EAAII,OAGJ1B,EAAIqB,EAAIf,OACRP,EAAM,GACAI,EAAI,EAAGA,EAAIH,EAAGG,IAKnB,GAJAoB,EAAKF,EAAKlB,GAIK,QADfe,EAAQS,EAAWJ,IAQnB,IAHAL,EAAQtB,EAAc0B,EAAKJ,EAAMQ,QAG3BtB,EAAI,EAAGA,EAAIc,EAAMZ,OAAQF,IAC9BL,EAAIQ,KAAMgB,EAAIL,EAAOd,IAGvB,GAAKe,EAAKS,MAAQ,CAEjB,IADAR,EAAM,GACAjB,EAAI,EAAGA,EAAIJ,EAAIO,OAAQH,IAC5BiB,EAAIb,KAAMsB,EAAa9B,EAAKI,KAE7BJ,EAAMqB,CACN,CACD,OAAOrB,CACR"}