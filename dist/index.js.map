{
  "version": 3,
  "sources": ["../lib/main.js", "../lib/index.js"],
  "sourcesContent": ["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar safeCasts = require( '@stdlib/ndarray-safe-casts' );\nvar resolveEnum = require( '@stdlib/strided-base-dtype-resolve-enum' );\nvar resolveStr = require( '@stdlib/strided-base-dtype-resolve-str' );\nvar format = require( '@stdlib/string-format' );\n\n\n// FUNCTIONS //\n\n/**\n* Returns the intersection of two sorted lists.\n*\n* @private\n* @param {ArrayLikeObject} list1 - first sorted list\n* @param {ArrayLikeObject} list2 - second sorted list\n* @returns {ArrayLikeObject} result\n*\n* @example\n* var list1 = [ 'a', 'b', 'c', 'd' ];\n* var list2 = [ 'b', 'd', 'e' ];\n*\n* var out = intersection( list1, list2 );\n* // returns [ 'b', 'd' ]\n*/\nfunction intersection( list1, list2 ) {\n\tvar out;\n\tvar M;\n\tvar N;\n\tvar v;\n\tvar i;\n\tvar j;\n\tvar k;\n\n\tM = list1.length;\n\tN = list2.length;\n\n\tout = [];\n\tk = 0;\n\tfor ( i = 0; i < M; i++ ) {\n\t\tif ( k >= N ) {\n\t\t\tbreak;\n\t\t}\n\t\tv = list1[ i ];\n\t\tfor ( j = k; j < N; j++ ) {\n\t\t\tif ( v === list2[ j ] ) {\n\t\t\t\tk = j + 1;\n\t\t\t\tout.push( v );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn out;\n}\n\n/**\n* Resolves a list of data types to data type strings.\n*\n* @private\n* @param {ArrayLikeObject} dtypes - list of data types\n* @returns {(StringArray|Error)} data type strings (or an error)\n*\n* @example\n* var out = resolve( [ 1, 2, 3 ] );\n* // returns [...]\n*/\nfunction resolve( dtypes ) {\n\tvar out;\n\tvar dt;\n\tvar i;\n\n\tout = [];\n\tfor ( i = 0; i < dtypes.length; i++ ) {\n\t\tdt = resolveStr( dtypes[ i ] );\n\t\tif ( dt === null ) {\n\t\t\treturn new TypeError( format( 'invalid argument. Must provide recognized data types. Unable to resolve a data type string. Value: `%s`.', dtypes[ i ] ) );\n\t\t}\n\t\tout.push( dt );\n\t}\n\treturn out;\n}\n\n\n// MAIN //\n\n/**\n* Generates a list of unary interface signatures from strided array data types.\n*\n* ## Notes\n*\n* -   The function returns a strided array having a stride length of `2` (i.e., every `2` elements define a unary interface signature).\n* -   For each signature (i.e., set of two consecutive non-overlapping strided array elements), the first element is the input data type and the second element is the return data type.\n* -   All signatures follow type promotion rules.\n*\n* @param {Array} dtypes1 - list of supported data types for the first argument\n* @param {Array} dtypes2 - list of supported data types for the output argument\n* @param {Options} [options] - options\n* @param {boolean} [options.enums=false] - boolean flag indicating whether to return signatures as a list of enumeration constants\n* @throws {TypeError} must provide recognized data types\n* @returns {Array} strided array containing unary interface signatures\n*\n* @example\n* var dtypes = [\n*     'float64',\n*     'float32',\n*     'int32',\n*     'uint8'\n* ];\n*\n* var sigs = signatures( dtypes, dtypes );\n* // e.g., returns [ 'float32', 'float32', ... ]\n*/\nfunction signatures( dtypes1, dtypes2, options ) {\n\tvar casts;\n\tvar opts;\n\tvar tmp;\n\tvar out;\n\tvar dt1;\n\tvar dt2;\n\tvar t1;\n\tvar M;\n\tvar i;\n\tvar j;\n\n\tif ( arguments.length > 2 ) {\n\t\topts = options;\n\t} else {\n\t\topts = {};\n\t}\n\t// Resolve the list of provided data types to data type strings:\n\tdt1 = resolve( dtypes1 );\n\tif ( dt1 instanceof Error ) {\n\t\tthrow dt1;\n\t}\n\tif ( dtypes2 === dtypes1 ) { // don't do work if we don't need to\n\t\tdt2 = dt1;\n\t} else {\n\t\tdt2 = resolve( dtypes2 );\n\t\tif ( dt2 instanceof Error ) {\n\t\t\tthrow dt2;\n\t\t}\n\t}\n\t// Sort the list of return dtypes:\n\tdt2.sort();\n\n\t// Generate the list of signatures...\n\tM = dt1.length;\n\tout = [];\n\tfor ( i = 0; i < M; i++ ) {\n\t\tt1 = dt1[ i ];\n\n\t\t// Resolve the list of safe casts for the input dtype:\n\t\tcasts = safeCasts( t1 );\n\t\tif ( casts === null ) {\n\t\t\tcontinue;\n\t\t}\n\t\t// Remove safe casts which are not among the supported output dtypes:\n\t\tcasts = intersection( dt2, casts.sort() );\n\n\t\t// Generate signatures for allowed casts...\n\t\tfor ( j = 0; j < casts.length; j++ ) {\n\t\t\tout.push( t1, casts[ j ] );\n\t\t}\n\t}\n\tif ( opts.enums ) {\n\t\ttmp = [];\n\t\tfor ( i = 0; i < out.length; i++ ) {\n\t\t\ttmp.push( resolveEnum( out[ i ] ) );\n\t\t}\n\t\tout = tmp;\n\t}\n\treturn out;\n}\n\n\n// EXPORTS //\n\nmodule.exports = signatures;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Generate a list of unary interface signatures from strided array data types.\n*\n* @module @stdlib/strided-base-unary-dtype-signatures\n*\n* @example\n* var signatures = require( '@stdlib/strided-base-unary-dtype-signatures' );\n*\n* var dtypes = [\n*     'float64',\n*     'float32',\n*     'int32',\n*     'uint8'\n* ];\n*\n* var sigs = signatures( dtypes, dtypes );\n* // e.g., returns [ 'float32', 'float32', ... ]\n*/\n\n// MODULES //\n\nvar main = require( './main.js' );\n\n\n// EXPORTS //\n\nmodule.exports = main;\n"],
  "mappings": "uGAAA,IAAAA,EAAAC,EAAA,SAAAC,EAAAC,EAAA,cAsBA,IAAIC,EAAY,QAAS,4BAA6B,EAClDC,EAAc,QAAS,yCAA0C,EACjEC,EAAa,QAAS,wCAAyC,EAC/DC,EAAS,QAAS,uBAAwB,EAoB9C,SAASC,EAAcC,EAAOC,EAAQ,CACrC,IAAIC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EAOJ,IALAL,EAAIH,EAAM,OACVI,EAAIH,EAAM,OAEVC,EAAM,CAAC,EACPM,EAAI,EACEF,EAAI,EAAGA,EAAIH,GACX,EAAAK,GAAKJ,GADSE,IAKnB,IADAD,EAAIL,EAAOM,CAAE,EACPC,EAAIC,EAAGD,EAAIH,EAAGG,IACnB,GAAKF,IAAMJ,EAAOM,CAAE,EAAI,CACvBC,EAAID,EAAI,EACRL,EAAI,KAAMG,CAAE,EACZ,KACD,CAGF,OAAOH,CACR,CAaA,SAASO,EAASC,EAAS,CAC1B,IAAIR,EACAS,EACAL,EAGJ,IADAJ,EAAM,CAAC,EACDI,EAAI,EAAGA,EAAII,EAAO,OAAQJ,IAAM,CAErC,GADAK,EAAKd,EAAYa,EAAQJ,CAAE,CAAE,EACxBK,IAAO,KACX,OAAO,IAAI,UAAWb,EAAQ,2GAA4GY,EAAQJ,CAAE,CAAE,CAAE,EAEzJJ,EAAI,KAAMS,CAAG,CACd,CACA,OAAOT,CACR,CAgCA,SAASU,EAAYC,EAASC,EAASC,EAAU,CAChD,IAAIC,EACAC,EACAC,EACAhB,EACAiB,EACAC,EACAC,EACAlB,EACAG,EACAC,EASJ,GAPK,UAAU,OAAS,EACvBU,EAAOF,EAEPE,EAAO,CAAC,EAGTE,EAAMV,EAASI,CAAQ,EAClBM,aAAe,MACnB,MAAMA,EAEP,GAAKL,IAAYD,EAChBO,EAAMD,UAENC,EAAMX,EAASK,CAAQ,EAClBM,aAAe,MACnB,MAAMA,EASR,IALAA,EAAI,KAAK,EAGTjB,EAAIgB,EAAI,OACRjB,EAAM,CAAC,EACDI,EAAI,EAAGA,EAAIH,EAAGG,IAKnB,GAJAe,EAAKF,EAAKb,CAAE,EAGZU,EAAQrB,EAAW0B,CAAG,EACjBL,IAAU,KAOf,IAHAA,EAAQjB,EAAcqB,EAAKJ,EAAM,KAAK,CAAE,EAGlCT,EAAI,EAAGA,EAAIS,EAAM,OAAQT,IAC9BL,EAAI,KAAMmB,EAAIL,EAAOT,CAAE,CAAE,EAG3B,GAAKU,EAAK,MAAQ,CAEjB,IADAC,EAAM,CAAC,EACDZ,EAAI,EAAGA,EAAIJ,EAAI,OAAQI,IAC5BY,EAAI,KAAMtB,EAAaM,EAAKI,CAAE,CAAE,CAAE,EAEnCJ,EAAMgB,CACP,CACA,OAAOhB,CACR,CAKAR,EAAO,QAAUkB,IC5JjB,IAAIU,EAAO,IAKX,OAAO,QAAUA",
  "names": ["require_main", "__commonJSMin", "exports", "module", "safeCasts", "resolveEnum", "resolveStr", "format", "intersection", "list1", "list2", "out", "M", "N", "v", "i", "j", "k", "resolve", "dtypes", "dt", "signatures", "dtypes1", "dtypes2", "options", "casts", "opts", "tmp", "dt1", "dt2", "t1", "main"]
}
